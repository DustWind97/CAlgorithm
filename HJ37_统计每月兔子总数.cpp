/*
C++ 动态规划
动规五部曲：
这⾥我们要⽤⼀个⼀维dp数组来保存递归的结果

1.确定dp数组以及下标的含义
dp[i]的定义为：第i个数的斐波那契数值是dp[i]
2.确定递推公式
状态转移⽅程 dp[i] = dp[i - 1] + dp[i - 2];
3.dp数组如何初始化
题⽬中把如何初始化也直接给我们了，如下：
4.确定遍历顺序
从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出， dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序
⼀定是从前到后遍历的
5.举例推导dp数组
如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是⼀致的。
*/

/*
此题的解题思路
方法一：递归法  f(n)=f(n-1)+f(n-2)  性能更差
方法二：迭代法
方法三：动态规划法
*/


/*************************************************************************************************************/
//方法一：递归
#include<iostream>
using namespace std;

int getSum(int n) { //求每个月兔子数
    if(n == 1 || n == 2) //n=1或2跳出递归
        return 1;
    return getSum(n - 1) + getSum(n - 2); //返回前两个月相加
}

int main(){
    int n;
    while(cin >> n){ //每次输入n
        cout << getSum(n) << endl; 
    }
    return 0;
}

/*************************************************************************************************************/
//动态规划
// #include<iostream>
// #include<vector>
// using namespace std;

// int main(){
//     int n;
//     while(cin >> n){ //每次输入n
//         vector<int> dp(n + 1);
//         dp[1] = 1; //初始第一个月
//         dp[2] = 1; //第二个月
//         for(int i = 3; i <= n; i++) //后面的每个月由前面的累加
//             dp[i] = dp[i - 1] + dp[i - 2];
//         cout << dp[n] << endl;
//     }
//     return 0;
// }

/*************************************************************************************************************/
//迭代
// #include<iostream>
// using namespace std;

// int main(){
//     int n;
//     while(cin >> n){ //每次输入n
//         if(n <= 2) //前两个月直接输出
//             cout << 1 << endl;
//         else{
//             int dpi_2 = 1; //初始化第1个月
//             int dpi_1 = 1; //初始化第2个月
//             int output = 0;
//             for(int i = 3; i <= n; i++){
//                 output = dpi_1 + dpi_2; //公式相加
//                 dpi_2 = dpi_1; //变量更新
//                 dpi_1 = output;
//             }
//             cout << output << endl;
//         }
//     }
//     return 0;
// }
/*************************************************************************************************************/